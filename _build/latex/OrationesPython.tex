% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{OrationesPython Documentation}
\date{December 13, 2013}
\release{1.0.1}
\author{Timo Mätäsaho}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Contents:


\chapter{Documentation for the Code}
\label{code::doc}\label{code:documentation-for-the-code}\label{code:welcome-to-orationespython-s-documentation}

\section{Orationes Search}
\label{code:module-osearch}\label{code:orationes-search}\index{osearch (module)}\index{init() (in module osearch)}

\begin{fulllineitems}
\phantomsection\label{code:osearch.init}\pysiglinewithargsret{\code{osearch.}\bfcode{init}}{\emph{sysargv}}{}
The first function to be called when this script is run. Checks if the system arguments are correct 
and returns error when needed.

When calling from PHP use the \$output and \$return\_var arguments to catch the correct output and 
possible return error code. If the \$return\_var is 1 then the program has finished without errors.

Refer to PHP \href{http://php.net/function.exec}{exec} command manual for further information of calling 
Python scripts and programs in general from PHP.

\end{fulllineitems}

\index{osearch() (in module osearch)}

\begin{fulllineitems}
\phantomsection\label{code:osearch.osearch}\pysiglinewithargsret{\code{osearch.}\bfcode{osearch}}{\emph{img}, \emph{switch}, \emph{txtf}, \emph{sw}}{}
The main program that only calls the processing methods from OratUtils and HFun classes.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{img} (\emph{string}) -- The name of the image.

\item {} 
\textbf{txtf} (\emph{string}) -- The name of the cleaned XML file.

\item {} 
\textbf{sw} (\emph{string}) -- The word or letter that is searched.

\end{itemize}

\item[{Returns}] \leavevmode
error code or 1 and JSON string

\end{description}\end{quote}
\begin{description}
\item[{The error codes are:}] \leavevmode
2 - Error in starting parameters
3 - Given image doesn't exist, it's path is faulty or its format is wrong or either the image file is corrupted.
4 - Given string or character to be searched cannot be found from the XML
5 - 
6 - 
7 - 
8 - 
9 - Unknown error while opening the image

\end{description}

There are still lots of places that are missing error handling!

The return option have to be chosen between returning the string as a return code or 
is it just printed out for the calling PHP program. Currently it is being printed.

\end{fulllineitems}



\section{Orationes getBoxes}
\label{code:orationes-getboxes}\label{code:module-getBoxes}\index{getBoxes (module)}\index{getBoxesAndLines() (in module getBoxes)}

\begin{fulllineitems}
\phantomsection\label{code:getBoxes.getBoxesAndLines}\pysiglinewithargsret{\code{getBoxes.}\bfcode{getBoxesAndLines}}{\emph{img}}{}
Optional directly callable program that can be used to extract the bounding box
and line location information from an image.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{img} (\emph{string}) -- The name of the image.

\item[{Returns}] \leavevmode
JSON string

\end{description}\end{quote}

Returns a JSON array containing the possible locations of the text lines and 
bounding boxes.

\end{fulllineitems}



\section{Utility functions}
\label{code:module-OratUtils}\label{code:utility-functions}\index{OratUtils (module)}\index{OratUtils (class in OratUtils)}

\begin{fulllineitems}
\phantomsection\label{code:OratUtils.OratUtils}\pysigline{\strong{class }\code{OratUtils.}\bfcode{OratUtils}}
This class contains only static utility methods that are called directly from the main program `osearch.py'.
\index{boundingBox() (OratUtils.OratUtils static method)}

\begin{fulllineitems}
\phantomsection\label{code:OratUtils.OratUtils.boundingBox}\pysiglinewithargsret{\strong{static }\bfcode{boundingBox}}{\emph{image}, \emph{debug}}{}
This functions tries to determine the bounding boxes for each text line.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{image} (\emph{ndarray}) -- the processed image

\item {} 
\textbf{debug} (\emph{bool}) -- debug switch

\end{itemize}

\item[{Returns}] \leavevmode
ndarray -- bboxes

\end{description}\end{quote}
\begin{gather}
\begin{split}bboxes_{nxm} = 
\begin{bmatrix}
        \text{patch label numbers}\\
        \text{starting x-coordinates}\\
        \text{starting y-coordinates}\\
        \text{ending x-coordinates}\\
        \text{ending y-coordinates}
\end{bmatrix}\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}
\emph{debug} switch can be used to plot the results of the bounding box 
founding method and to see whether it is working correctly.

Process pipeline:
\begin{enumerate}
\item {} 
Calculate the histogram from the image

\item {} 
Binarize image with threshold 0.95

\item {} 
Label all the patched in on the binarized image

\item {} 
Calculate the sizes of the patches

\item {} 
Remove unnecessary patches
\begin{enumerate}
\item {} 
Remove the largest patch. The largest patch is always the patch consisting of the borders and marginals.

\item {} 
Remove patches which size is smaller or equal to 50 pixels

\item {} 
Remove all the patches which are higher than 70 pixels. This removes the possible remaining marginal patches which weren't connected to the major marginal and border patch.

\end{enumerate}

\item {} 
Perform morpholig operations to clean the image and bind the text lines together
\begin{enumerate}
\item {} 
Perform erosion with a cross like structure element
\begin{quote}
\begin{gather}
\begin{split}SEe_{5,5} = 
\begin{bmatrix}
        0 & 0 & 1 & 0 & 0 \\
        0 & 0 & 1 & 0 & 0 \\
        0 & 1 & 1 & 1 & 0 \\
        0 & 0 & 1 & 0 & 0 \\
        0 & 0 & 1 & 0 & 0
\end{bmatrix}\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}\end{quote}

\item {} 
Perform dilation with a long vertical line. (needs a 70x70 size structure element)
\begin{quote}
\begin{gather}
\begin{split}SEd_{70,70} = 
\begin{bmatrix}
        0 & 0 & \dots & 0 & 0 \\
          & \vdots & & \vdots & \\
        1 & 1 & \dots & 1 & 1 \\
          & \vdots & & \vdots & \\
        0 & 0 & \dots & 0 & 0
\end{bmatrix}\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}\end{quote}

\end{enumerate}

\item {} 
Label the morphologically operated image

\item {} 
Remove patches which size is less or equal to 4000 pixels

\item {} 
Label the image again with new labels

\item {} 
Calculate the extreme dimensions of each patch. These values are used as the limiting bounding boxes.

\item {} 
Combine the boxes which are horizontally too close as they are thought to be separate boxes on the same textline.

\item {} 
Return the bounding boxes

\end{enumerate}

\end{fulllineitems}

\index{contStretch() (OratUtils.OratUtils static method)}

\begin{fulllineitems}
\phantomsection\label{code:OratUtils.OratUtils.contStretch}\pysiglinewithargsret{\strong{static }\bfcode{contStretch}}{\emph{im}, \emph{a}, \emph{h}}{}
Performs contrast stretching for grayscale images. Pixel intensities are set to 
differ `a' times the average intensity from the original intensity values. The new 
intensity values are sliced to stay between {[}0, 255{]}.
\begin{gather}
\begin{split}I_{stretched} = I_{old} + a*( I_{old} - I_{average} )\end{split}\notag\\\begin{split}I_{new} =
\left\{
\begin{array}[l]{ll}
  0, & I_{stretched} < 0 \\
  I_{stretched}, & 0 \leq I_{stretched} \leq 255\\
  255, & I_{stretched} > 255
\end{array}
\right.\end{split}\notag
\end{gather}\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{im} (\emph{ndarray}) -- The image which contrast is to be stretched

\item {} 
\textbf{a} (\emph{int}) -- multiplication coefficient

\item {} 
\textbf{h} (\emph{int}) -- The height of image. Used as partial image average switch

\end{itemize}

\item[{Returns}] \leavevmode
ndarray -- contrast stretched image

\end{description}\end{quote}

Parameter \emph{h} is a switch which could be used to determine if the average intensity 
is calculated over the whole image or from a small portion of it. Currently it is 
defaulted in the code to newer happen. Originally the idea was that if the image 
is very big, the intensity average would be taken from a small sample. To make the 
function more generic and also because of the nature of the images in Orationes 
project, it was decided that the average is always calculated over the whole image.

\end{fulllineitems}

\index{findCorr() (OratUtils.OratUtils static method)}

\begin{fulllineitems}
\phantomsection\label{code:OratUtils.OratUtils.findCorr}\pysiglinewithargsret{\strong{static }\bfcode{findCorr}}{\emph{bboxes}, \emph{slines}, \emph{charcount}, \emph{imlines}, \emph{debug}}{}
Used to find out which bounding box and which line are the same.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{bboxes} (\emph{ndarray}) -- Ndarray containing the coordinates of the bounding boxes

\item {} 
\textbf{slines} (\emph{ndarray}) -- A vector containing the y-coordinates of the interesting lines

\item {} 
\textbf{charcount} (\emph{list}) -- Contains the lengths of each line

\item {} 
\textbf{imlines} (\emph{ndarray}) -- n*1 size ndarray containing the lines (or rather their y-position) got from the image by radontransform

\item {} 
\textbf{debug} (\emph{bool}) -- Debug switch

\end{itemize}

\item[{Returns}] \leavevmode
ndarray -- m*n ndarray containing the starting and ending coordinates of hits

\end{description}\end{quote}

\end{fulllineitems}

\index{hfilter() (OratUtils.OratUtils static method)}

\begin{fulllineitems}
\phantomsection\label{code:OratUtils.OratUtils.hfilter}\pysiglinewithargsret{\strong{static }\bfcode{hfilter}}{\emph{image}, \emph{diameter}, \emph{height}, \emph{length}, \emph{n}}{}
This function performs homomorphic filtering on grayscale images.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{image} (\emph{ndarray}) -- 2-dimensional ndarray

\item {} 
\textbf{diameter} (\emph{int}) -- filter diameter

\item {} 
\textbf{height} (\emph{int}) -- Height of the image

\item {} 
\textbf{length} (\emph{int}) -- Length of the image

\item {} 
\textbf{n} (\emph{int}) -- Filter order

\end{itemize}

\item[{Returns}] \leavevmode
ndarray -- homomorphically filtered image

\end{description}\end{quote}

The image must in ndarray format. In osearch PIL images are converted to scipy images which 
are in ndarray format. Ndarray format allows easy and fast direct access to the pixel values 
and this function is written entirely only for the ndarrays.

\end{fulllineitems}

\index{packBoxesAndLines() (OratUtils.OratUtils static method)}

\begin{fulllineitems}
\phantomsection\label{code:OratUtils.OratUtils.packBoxesAndLines}\pysiglinewithargsret{\strong{static }\bfcode{packBoxesAndLines}}{\emph{bboxes}, \emph{imlines}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{bboxes} (\emph{ndarray}) -- Ndarray containing the coordinates of the bounding boxes

\item {} 
\textbf{imlines} (\emph{ndarray}) -- n*1 size ndarray containing the lines (or rather their y-position) got from the image by radontransform

\end{itemize}

\item[{Returns}] \leavevmode
jsondata -- JSON packed string containing the found bounding boxes and lines

\end{description}\end{quote}

\end{fulllineitems}

\index{packCoordsToJson() (OratUtils.OratUtils static method)}

\begin{fulllineitems}
\phantomsection\label{code:OratUtils.OratUtils.packCoordsToJson}\pysiglinewithargsret{\strong{static }\bfcode{packCoordsToJson}}{\emph{slines}, \emph{origimage}, \emph{coords}, \emph{charpos}, \emph{wordlens}, \emph{bboxes}, \emph{debug}}{}
This function is used to pack the hit coordinates and bounding box coordinates 
into a JSON string which is returned to the calling PHP site.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{slines} (\emph{ndarray}) -- A vector containing the y-coordinates of the interesting lines

\item {} 
\textbf{origimage} (\emph{ndarray}) -- Original image. Used when debugging

\item {} 
\textbf{coords} (\emph{ndarray}) -- A ndarray containing the coordinates of the hits

\item {} 
\textbf{charpos} (\emph{list of lists}) -- List of the character positions got from the XML

\item {} 
\textbf{wordlens} (\emph{list of lists}) -- List of wordlengths

\item {} 
\textbf{bboxes} (\emph{ndarray}) -- Ndarray containing the coordinates of the bounding boxes

\item {} 
\textbf{debug} (\emph{bool}) -- Debug switch

\end{itemize}

\item[{Returns}] \leavevmode
json-string -- JSON packed string containing the hits and the bounding boxes

\end{description}\end{quote}

\end{fulllineitems}

\index{padlines() (OratUtils.OratUtils static method)}

\begin{fulllineitems}
\phantomsection\label{code:OratUtils.OratUtils.padlines}\pysiglinewithargsret{\strong{static }\bfcode{padlines}}{\emph{imlines}, \emph{llines}, \emph{charlines}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{imlines} (\emph{ndarray}) -- n*1 size ndarray containing the lines (or rather their y-position) got from the image by radontransform

\item {} 
\textbf{llines} (\emph{ndarray}) -- n*2 size ndarray containing the length information of the lines

\item {} 
\textbf{charlines} (\emph{list}) -- list of lists telling the position(s) of searched character(s)/word(s) on each line

\end{itemize}

\item[{Returns}] \leavevmode
ndarray -- wantedlines

\end{description}\end{quote}

Long:
Llines contains the information about the lines got from the XML and also it contains the 
information if some of the lines are remarkably shorter than other lines. That means that, if there are some lines that 
are not found from the image, it is assumed that those non-found lines are the shortest lines according to the XML and 
character count. Those lines are marked as 0 in the second column in llines.

Short:
Llines{[}:,1{]} contains only 1s and 0s. 1 meaning a line with enough letters to be recognized by poormanradon (pmr) 
and 0 meaning a line which is probably undetected by pmr
\begin{description}
\item[{Behavior:}] \leavevmode
Number of lines found from the image using pmr is larger than 
the number of lines calculated from XML:
\begin{quote}

TODO! Currently this case is not handled!
\end{quote}

Number of lines found from the image using pmr is smaller than
the number of lines calculated from XML:
\begin{quote}

Pad the lines according to the information in \emph{llines{[}:,1{]}}:
\end{quote}
\begin{gather}
\begin{split}\stackrel{\mbox{llines}}{ \begin{bmatrix} 1 \\ 1 \\ 1 \\ 1 \\ 0 \\ 1 \\ 1 \\ 0 \\ 1 \end{bmatrix} }
\begin{matrix} \searrow \\ \searrow \\ \searrow \\ \searrow \\ ~ \\ \longrightarrow \\ \longrightarrow \\ ~ \\ \nearrow \end{matrix}
\stackrel{\mbox{imlines}}{ \begin{bmatrix} 100 \\ 200 \\ 300 \\ 400 \\ 600 \\ 700 \\ 900 \end{bmatrix} }
\begin{matrix} \nearrow \\ \nearrow \\ \nearrow \\ \nearrow \\ ~ \\ \longrightarrow \\ \longrightarrow \\ ~ \\ \searrow \end{matrix}
\stackrel{\mbox{rlines}}{ \begin{bmatrix} 100 \\ 200 \\ 300 \\ 400 \\ NAN \\ 600 \\ 700 \\ NAN \\ 900 \end{bmatrix} } \\
\\ ~\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}
Number of lines found from the image using pmr equals to
the number of lines calculated from XML:
\begin{quote}

Pick unique lines from imlines and return them as lines 
the interesting lines.
\end{quote}

\end{description}

\end{fulllineitems}

\index{poormanradon() (OratUtils.OratUtils static method)}

\begin{fulllineitems}
\phantomsection\label{code:OratUtils.OratUtils.poormanradon}\pysiglinewithargsret{\strong{static }\bfcode{poormanradon}}{\emph{image}, \emph{iname}, \emph{height}, \emph{debug}}{}
Performs a naive radon-transform and peak detection on the binarized 
and contrast stretched image and tries to determine where the text 
lines are in the image.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{image} (\emph{ndarray}) -- Image

\item {} 
\textbf{iname} (\emph{string}) -- Image name

\item {} 
\textbf{height} (\emph{int}) -- Image height

\item {} 
\textbf{debug} (\emph{bool}) -- Debug switch

\end{itemize}

\item[{Returns}] \leavevmode
ndarray -- Array containing the lines which are found using radon transform

\end{description}\end{quote}

Calculates the intensity sums over each vertical line. The sums are then inverted and 
peaks are detected from the inverted data. Data inversion wouldn't be necessary in the 
python code, but this convetion comes from the Matlab code that was ported to python.

Before the transform, the image is cleaned so that by using static values ( very bad, 
should be dynamic, but so far there hasn't been time to do that ) the marginals and 
everything outside them is erased and turned to white. Because the distance between 
the camera and the page differs in each image, the marginals aren't always on the 
same position. This combined with static values causes inaccuracy in the erasing 
process and might cause inaccuracy when detecting the peaks and the lines.

In the peak detection, it is assumed that a spike is considered a peak if it's 25 units 
away from a previous detected peak and also if its value difference is at least 1500 
to its previous value.

\emph{upLim} in the source means upper limit in the image coordinates, which increase when 
going down in the image. That's why \emph{upLim} is small. Respectively the 
\emph{downLim} means the bottom limit in the image coordinates and that's why it's bigger 
than the upper limit.

\end{fulllineitems}

\index{processlines() (OratUtils.OratUtils static method)}

\begin{fulllineitems}
\phantomsection\label{code:OratUtils.OratUtils.processlines}\pysiglinewithargsret{\strong{static }\bfcode{processlines}}{\emph{charcount}, \emph{imlines}}{}
This functions compares the number of lines found from the image to the 
number of lines found from the XML file and creates a logical vector 
telling which lines are probably found and which are not.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{charcount} (\emph{list}) -- Contains the lengths of each line

\item {} 
\textbf{imlines} (\emph{ndarray}) -- Contains the textlines which are found in `poormanradon'

\end{itemize}

\item[{Returns}] \leavevmode
ndarray -- llines

\item[{Returns}] \leavevmode
ndarray -- imlines

\end{description}\end{quote}

\emph{llines} is a n*2 vector, where the llines{[}:,1{]} is a logical vector 
containing the information of the probably found and non-found lines.
\begin{gather}
\begin{split}[1,1,1,1,0,1,0,1, \dots ]^t\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}
\emph{imlines} is a ndarray containing the y-coordinates of the textlines 
found from the image with poormanradon. When padding some of the 
coordinates are removed ( nofound \textless{} 0, not used ), some NAN 
values are added in between some coordinates ( nofound \textgreater{} 0 ) or 
it is returned unchanged ( nofound == 0 ).

We calculate a number `nofound'
\begin{gather}
\begin{split}\operatorname{nofound}=\operatorname{lines}_{XML}-\operatorname{lines}_{image}\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}
Naturally there are three cases.
\begin{description}
\item[{nofound \textless{} 0:}] \leavevmode
This means that there are more lines found from the image than there 
actually are. Currently nothing's done here to compensate this 
behavior.

\item[{nofound \textgreater{} 0:}] \leavevmode
This means there aren't enough lines found from the image. Usually the 
non-found lines are assumed to be the very short lines. When padding 
the indices of the lines, the shortest lines are always set to be 
the non-found lines.

\item[{nofound == 0:}] \leavevmode
It is assumed that all the textlines were found correctly and the 
imlines will be returned unchanged.

\end{description}

\end{fulllineitems}

\index{stringparser() (OratUtils.OratUtils static method)}

\begin{fulllineitems}
\phantomsection\label{code:OratUtils.OratUtils.stringparser}\pysiglinewithargsret{\strong{static }\bfcode{stringparser}}{\emph{tfile}, \emph{c}}{}
Performs case sensitive search for text file tfile with string or character c (char on default).
Argument c can be any regular expression
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{tfile} (\emph{string}) -- The string containing the cleaned XML file as a string

\item {} 
\textbf{c} (\emph{string/char/regular expression}) -- The letter or string that is searched from the tfile

\end{itemize}

\item[{Returns}] \leavevmode
list -- charcount

\item[{Returns}] \leavevmode
list of lists -- charpos

\item[{Returns}] \leavevmode
list of lists -- charlines

\item[{Returns}] \leavevmode
list of lists -- wordlens

\end{description}\end{quote}
\begin{itemize}
\item {} 
\emph{Charcount} is a list containing the lengths of each line.
\begin{itemize}
\item {} 
\code{{[}63, 60, 4, 65, 66, 37, 66, ...{]}}

\end{itemize}

\item {} 
\emph{Charpos} is a list containing lists including the positions of the found characters or the first letters of the found words.
\begin{itemize}
\item {} 
\code{{[}{[}52{]}, {[}10, 47, 62{]}, {[}19, 62{]}, {[}51{]}, ...{]}}

\end{itemize}

\item {} 
\emph{Charlines} is a list of lists where the length of each sublist tells the number of hits on that line and the element values representing the line number from the XML file.
\begin{itemize}
\item {} 
\code{{[}{[}3{]}, {[}4, 4, 4{]}, {[}6, 6{]}, {[}7{]}, ...{]}}

\end{itemize}

\item {} 
\emph{Wordlens} is a list containing lists containing the lengths of the words on each line.
\begin{itemize}
\item {} 
\code{{[}{[}3{]}, {[}3, 3, 3{]}, {[}3, 3{]}, {[}3{]}, ...{]}}

\end{itemize}

\end{itemize}

\end{fulllineitems}

\index{txtfparser() (OratUtils.OratUtils static method)}

\begin{fulllineitems}
\phantomsection\label{code:OratUtils.OratUtils.txtfparser}\pysiglinewithargsret{\strong{static }\bfcode{txtfparser}}{\emph{tfile}, \emph{c}}{}
Performs case sensitive search for text file tfile with string or character c (char on default).
Argument c can be any regular expression
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{tfile} (\emph{string}) -- The name of the cleaned XML file

\item {} 
\textbf{c} (\emph{string/char/regular expression}) -- The letter or string that is searched from the tfile

\end{itemize}

\item[{Returns}] \leavevmode
list -- charcount

\item[{Returns}] \leavevmode
list of lists -- charpos

\item[{Returns}] \leavevmode
list of lists -- charlines

\item[{Returns}] \leavevmode
list of lists -- wordlens

\end{description}\end{quote}
\begin{itemize}
\item {} 
\emph{Charcount} is a list containing the lengths of each line.
\begin{itemize}
\item {} 
\code{{[}63, 60, 4, 65, 66, 37, 66, ...{]}}

\end{itemize}

\item {} 
\emph{Charpos} is a list containing lists including the positions of the found characters or the first letters of the found words.
\begin{itemize}
\item {} 
\code{{[}{[}52{]}, {[}10, 47, 62{]}, {[}19, 62{]}, {[}51{]}, ...{]}}

\end{itemize}

\item {} 
\emph{Charlines} is a list of lists where the length of each sublist tells the number of hits on that line and the element values representing the line number from the XML file.
\begin{itemize}
\item {} 
\code{{[}{[}3{]}, {[}4, 4, 4{]}, {[}6, 6{]}, {[}7{]}, ...{]}}

\end{itemize}

\item {} 
\emph{Wordlens} is a list containing lists containing the lengths of the words on each line.
\begin{itemize}
\item {} 
\code{{[}{[}3{]}, {[}3, 3, 3{]}, {[}3, 3{]}, {[}3{]}, ...{]}}

\end{itemize}

\end{itemize}

\end{fulllineitems}


\end{fulllineitems}



\section{Helper Functions}
\label{code:helper-functions}\index{HFun (class in OratUtils)}

\begin{fulllineitems}
\phantomsection\label{code:OratUtils.HFun}\pysigline{\strong{class }\code{OratUtils.}\bfcode{HFun}}
Contains helper functions that are used in various places
\index{gray2uint8() (OratUtils.HFun static method)}

\begin{fulllineitems}
\phantomsection\label{code:OratUtils.HFun.gray2uint8}\pysiglinewithargsret{\strong{static }\bfcode{gray2uint8}}{\emph{image}}{}
Converts grasycale images to uint8 type
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{image} (\emph{ndarray}) -- The grayscale image to converted

\item[{Returns}] \leavevmode
ndarray( uint8 ) - I

\end{description}\end{quote}

\end{fulllineitems}

\index{im2float() (OratUtils.HFun static method)}

\begin{fulllineitems}
\phantomsection\label{code:OratUtils.HFun.im2float}\pysiglinewithargsret{\strong{static }\bfcode{im2float}}{\emph{image}}{}
Changes uint8 type images to float64 images.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{image} (\emph{ndarray( uint8 )}) -- The image to be converted

\item[{Returns}] \leavevmode
ndarray( float64 ) -- I

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{Peakdetection}
\label{code:peakdetection}
This is the only part not written by me (the author of this program), thus all the glory and honors and what so ever goes to its right authors. Only one function is used.
For more info about this module see \href{https://gist.github.com/sixtenbe/1178136}{Sixtenbe's github}

NOTE that this file might not follow the Sphinx documentation guidelines and might not appear correctly!
\phantomsection\label{code:module-peakdet}\index{peakdet (module)}\index{peakdetect() (in module peakdet)}

\begin{fulllineitems}
\phantomsection\label{code:peakdet.peakdetect}\pysiglinewithargsret{\code{peakdet.}\bfcode{peakdetect}}{\emph{y\_axis}, \emph{x\_axis=None}, \emph{lookahead=300}, \emph{delta=0}}{}
Converted from/based on a MATLAB script at: 
\href{http://billauer.co.il/peakdet.html}{http://billauer.co.il/peakdet.html}

function for detecting local maximas and minmias in a signal.
Discovers peaks by searching for values which are surrounded by lower
or larger values for maximas and minimas respectively

keyword arguments:
y\_axis -- A list containg the signal over which to find peaks
x\_axis -- (optional) A x-axis whose values correspond to the y\_axis list
\begin{quote}

and is used in the return to specify the postion of the peaks. If
omitted an index of the y\_axis is used. (default: None)
\end{quote}
\begin{description}
\item[{lookahead -- (optional) distance to look ahead from a peak candidate to}] \leavevmode
determine if it is the actual peak (default: 200) 
`(sample / period) / f' where `4 \textgreater{}= f \textgreater{}= 1.25' might be a good value

\item[{delta -- (optional) this specifies a minimum difference between a peak and}] \leavevmode
the following points, before a peak may be considered a peak. Useful
to hinder the function from picking up false peaks towards to end of
the signal. To work well delta should be set to delta \textgreater{}= RMSnoise * 5.
(default: 0)
\begin{quote}

delta function causes a 20\% decrease in speed, when omitted
Correctly used it can double the speed of the function
\end{quote}

\item[{return -- two lists {[}max\_peaks, min\_peaks{]} containing the positive and}] \leavevmode
negative peaks respectively. Each cell of the lists contains a tupple
of: (position, peak\_value) 
to get the average peak value do: np.mean(max\_peaks, 0){[}1{]} on the
results to unpack one of the lists into x, y coordinates do: 
x, y = zip({\color{red}\bfseries{}*}tab)

\end{description}

\end{fulllineitems}

\index{peakdetect\_fft() (in module peakdet)}

\begin{fulllineitems}
\phantomsection\label{code:peakdet.peakdetect_fft}\pysiglinewithargsret{\code{peakdet.}\bfcode{peakdetect\_fft}}{\emph{y\_axis}, \emph{x\_axis}, \emph{pad\_len=5}}{}
Performs a FFT calculation on the data and zero-pads the results to
increase the time domain resolution after performing the inverse fft and
send the data to the `peakdetect' function for peak 
detection.

Omitting the x\_axis is forbidden as it would make the resulting x\_axis
value silly if it was returned as the index 50.234 or similar.

Will find at least 1 less peak then the `peakdetect\_zero\_crossing'
function, but should result in a more precise value of the peak as
resolution has been increased. Some peaks are lost in an attempt to
minimize spectral leakage by calculating the fft between two zero
crossings for n amount of signal periods.

The biggest time eater in this function is the ifft and thereafter it's
the `peakdetect' function which takes only half the time of the ifft.
Speed improvementd could include to check if 2**n points could be used for
fft and ifft or change the `peakdetect' to the `peakdetect\_zero\_crossing',
which is maybe 10 times faster than `peakdetct'. The pro of `peakdetect'
is that it resutls in one less lost peak. It should also be noted that the
time used by the ifft function can change greatly depending on the input.

keyword arguments:
y\_axis -- A list containg the signal over which to find peaks
x\_axis -- A x-axis whose values correspond to the y\_axis list and is used
\begin{quote}

in the return to specify the postion of the peaks.
\end{quote}
\begin{description}
\item[{pad\_len -- (optional) By how many times the time resolution should be}] \leavevmode
increased by, e.g. 1 doubles the resolution. The amount is rounded up
to the nearest 2 ** n amount (default: 5)

\item[{return -- two lists {[}max\_peaks, min\_peaks{]} containing the positive and}] \leavevmode
negative peaks respectively. Each cell of the lists contains a tupple
of: (position, peak\_value) 
to get the average peak value do: np.mean(max\_peaks, 0){[}1{]} on the
results to unpack one of the lists into x, y coordinates do: 
x, y = zip({\color{red}\bfseries{}*}tab)

\end{description}

\end{fulllineitems}

\index{peakdetect\_parabole() (in module peakdet)}

\begin{fulllineitems}
\phantomsection\label{code:peakdet.peakdetect_parabole}\pysiglinewithargsret{\code{peakdet.}\bfcode{peakdetect\_parabole}}{\emph{y\_axis}, \emph{x\_axis}, \emph{points=9}}{}
Function for detecting local maximas and minmias in a signal.
Discovers peaks by fitting the model function: y = k (x - tau) ** 2 + m
to the peaks. The amount of points used in the fitting is set by the
points argument.

Omitting the x\_axis is forbidden as it would make the resulting x\_axis
value silly if it was returned as index 50.234 or similar.

will find the same amount of peaks as the `peakdetect\_zero\_crossing'
function, but might result in a more precise value of the peak.

keyword arguments:
y\_axis -- A list containg the signal over which to find peaks
x\_axis -- A x-axis whose values correspond to the y\_axis list and is used
\begin{quote}

in the return to specify the postion of the peaks.
\end{quote}
\begin{description}
\item[{points -- (optional) How many points around the peak should be used during}] \leavevmode
curve fitting, must be odd (default: 9)

\item[{return -- two lists {[}max\_peaks, min\_peaks{]} containing the positive and}] \leavevmode
negative peaks respectively. Each cell of the lists contains a list
of: (position, peak\_value) 
to get the average peak value do: np.mean(max\_peaks, 0){[}1{]} on the
results to unpack one of the lists into x, y coordinates do: 
x, y = zip({\color{red}\bfseries{}*}max\_peaks)

\end{description}

\end{fulllineitems}

\index{peakdetect\_sine() (in module peakdet)}

\begin{fulllineitems}
\phantomsection\label{code:peakdet.peakdetect_sine}\pysiglinewithargsret{\code{peakdet.}\bfcode{peakdetect\_sine}}{\emph{y\_axis}, \emph{x\_axis}, \emph{points=9}, \emph{lock\_frequency=False}}{}
Function for detecting local maximas and minmias in a signal.
Discovers peaks by fitting the model function:
y = A * sin(2 * pi * f * x - tau) to the peaks. The amount of points used
in the fitting is set by the points argument.

Omitting the x\_axis is forbidden as it would make the resulting x\_axis
value silly if it was returned as index 50.234 or similar.

will find the same amount of peaks as the `peakdetect\_zero\_crossing'
function, but might result in a more precise value of the peak.

The function might have some problems if the sine wave has a
non-negligible total angle i.e. a k*x component, as this messes with the
internal offset calculation of the peaks, might be fixed by fitting a 
k * x + m function to the peaks for offset calculation.

keyword arguments:
y\_axis -- A list containg the signal over which to find peaks
x\_axis -- A x-axis whose values correspond to the y\_axis list and is used
\begin{quote}

in the return to specify the postion of the peaks.
\end{quote}
\begin{description}
\item[{points -- (optional) How many points around the peak should be used during}] \leavevmode
curve fitting, must be odd (default: 9)

\item[{lock\_frequency -- (optional) Specifies if the frequency argument of the}] \leavevmode
model function should be locked to the value calculated from the raw
peaks or if optimization process may tinker with it. (default: False)

\item[{return -- two lists {[}max\_peaks, min\_peaks{]} containing the positive and}] \leavevmode
negative peaks respectively. Each cell of the lists contains a tupple
of: (position, peak\_value) 
to get the average peak value do: np.mean(max\_peaks, 0){[}1{]} on the
results to unpack one of the lists into x, y coordinates do: 
x, y = zip({\color{red}\bfseries{}*}tab)

\end{description}

\end{fulllineitems}

\index{peakdetect\_sine\_locked() (in module peakdet)}

\begin{fulllineitems}
\phantomsection\label{code:peakdet.peakdetect_sine_locked}\pysiglinewithargsret{\code{peakdet.}\bfcode{peakdetect\_sine\_locked}}{\emph{y\_axis}, \emph{x\_axis}, \emph{points=9}}{}
Convinience function for calling the `peakdetect\_sine' function with
the lock\_frequency argument as True.

keyword arguments:
y\_axis -- A list containg the signal over which to find peaks
x\_axis -- A x-axis whose values correspond to the y\_axis list and is used
\begin{quote}

in the return to specify the postion of the peaks.
\end{quote}
\begin{description}
\item[{points -- (optional) How many points around the peak should be used during}] \leavevmode
curve fitting, must be odd (default: 9)

\end{description}

return -- see `peakdetect\_sine'

\end{fulllineitems}

\index{peakdetect\_zero\_crossing() (in module peakdet)}

\begin{fulllineitems}
\phantomsection\label{code:peakdet.peakdetect_zero_crossing}\pysiglinewithargsret{\code{peakdet.}\bfcode{peakdetect\_zero\_crossing}}{\emph{y\_axis}, \emph{x\_axis=None}, \emph{window=11}}{}
Function for detecting local maximas and minmias in a signal.
Discovers peaks by dividing the signal into bins and retrieving the
maximum and minimum value of each the even and odd bins respectively.
Division into bins is performed by smoothing the curve and finding the
zero crossings.

Suitable for repeatable signals, where some noise is tolerated. Excecutes
faster than `peakdetect', although this function will break if the offset
of the signal is too large. It should also be noted that the first and
last peak will probably not be found, as this function only can find peaks
between the first and last zero crossing.

keyword arguments:
y\_axis -- A list containg the signal over which to find peaks
x\_axis -- (optional) A x-axis whose values correspond to the y\_axis list
\begin{quote}

and is used in the return to specify the postion of the peaks. If
omitted an index of the y\_axis is used. (default: None)
\end{quote}
\begin{description}
\item[{window -- the dimension of the smoothing window; should be an odd integer}] \leavevmode
(default: 11)

\item[{return -- two lists {[}max\_peaks, min\_peaks{]} containing the positive and}] \leavevmode
negative peaks respectively. Each cell of the lists contains a tupple
of: (position, peak\_value) 
to get the average peak value do: np.mean(max\_peaks, 0){[}1{]} on the
results to unpack one of the lists into x, y coordinates do: 
x, y = zip({\color{red}\bfseries{}*}tab)

\end{description}

\end{fulllineitems}

\index{zero\_crossings() (in module peakdet)}

\begin{fulllineitems}
\phantomsection\label{code:peakdet.zero_crossings}\pysiglinewithargsret{\code{peakdet.}\bfcode{zero\_crossings}}{\emph{y\_axis}, \emph{window=11}}{}
Algorithm to find zero crossings. Smoothens the curve and finds the
zero-crossings by looking for a sign change.

keyword arguments:
y\_axis -- A list containg the signal over which to find zero-crossings
window -- the dimension of the smoothing window; should be an odd integer
\begin{quote}

(default: 11)
\end{quote}

return -- the index for each zero-crossing

\end{fulllineitems}



\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{modindex}

\item {} 
\emph{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{g}
\item {\texttt{getBoxes}}, \pageref{code:module-getBoxes}
\indexspace
\bigletter{o}
\item {\texttt{OratUtils}}, \pageref{code:module-OratUtils}
\item {\texttt{osearch}}, \pageref{code:module-osearch}
\indexspace
\bigletter{p}
\item {\texttt{peakdet}}, \pageref{code:module-peakdet}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
