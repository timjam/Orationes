% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{OrationesPython Documentation}
\date{November 04, 2013}
\release{1.0.1}
\author{Timo Mätäsaho}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Contents:


\chapter{Documentation for the Code}
\label{code::doc}\label{code:documentation-for-the-code}\label{code:welcome-to-orationespython-s-documentation}

\section{Orationes Search}
\label{code:module-osearch}\label{code:orationes-search}\index{osearch (module)}\index{osearch() (in module osearch)}

\begin{fulllineitems}
\phantomsection\label{code:osearch.osearch}\pysiglinewithargsret{\code{osearch.}\bfcode{osearch}}{\emph{img}, \emph{txtf}, \emph{sw}}{}
The main program that only calls the processing methods from OratUtils and HFun classes.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{img} (\emph{string}) -- The name of the image.

\item {} 
\textbf{txtf} (\emph{string}) -- The name of the cleaned XML file.

\item {} 
\textbf{sw} (\emph{string}) -- The word or letter that is searched.

\end{itemize}

\item[{Returns}] \leavevmode
nothing or JSON string

\end{description}\end{quote}

The return option have to be chosen between returning the string as a return code or 
is it just printed out for the calling PHP program. Currently it is being printed.

\end{fulllineitems}



\section{OratUtils}
\label{code:oratutils}\index{OratUtils (class in osearch)}

\begin{fulllineitems}
\phantomsection\label{code:osearch.OratUtils}\pysigline{\strong{class }\code{osearch.}\bfcode{OratUtils}}
This class contains only static utility methods that are called directly from the main program `osearch.py'.
\index{boundingBox() (osearch.OratUtils static method)}

\begin{fulllineitems}
\phantomsection\label{code:osearch.OratUtils.boundingBox}\pysiglinewithargsret{\strong{static }\bfcode{boundingBox}}{\emph{image}, \emph{debug}}{}
This functions tries to determine the bounding boxes for each text line.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{image} (\emph{ndarray}) -- the processed image

\item {} 
\textbf{debug} (\emph{bool}) -- debug switch

\end{itemize}

\item[{Returns}] \leavevmode
ndarray -- bboxes

\end{description}\end{quote}
\begin{gather}
\begin{split}bboxes_{nxm} = 
\begin{bmatrix}
        \text{patch label numbers}\\
        \text{starting x-coordinates}\\
        \text{starting y-coordinates}\\
        \text{ending x-coordinates}\\
        \text{ending y-coordinates}
\end{bmatrix}\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}
\emph{debug} switch can be used to plot the results of the bounding box 
founding method and to see whether it is working correctly.

Process pipeline:
\begin{enumerate}
\item {} 
Calculate the histogram from the image

\item {} 
Binarize image with threshold 0.95

\item {} 
Label all the patched in on the binarized image

\item {} 
Calculate the sizes of the patches

\item {} 
Remove unnecessary patches
\begin{enumerate}
\item {} 
Remove the largest patch. The largest patch is always the patch consisting of the borders and marginals.

\item {} 
Remove patches which size is smaller or equal to 50 pixels

\item {} 
Remove all the patches which are higher than 70 pixels. This removes the possible remaining marginal patches which weren't connected to the major marginal and border patch.

\end{enumerate}

\item {} 
Perform morpholig operations to clean the image and bind the text lines together
\begin{enumerate}
\item {} 
Perform erosion with a cross like structure element
\begin{quote}
\begin{gather}
\begin{split}SEe_{5,5} = 
\begin{bmatrix}
        0 & 0 & 1 & 0 & 0 \\
        0 & 0 & 1 & 0 & 0 \\
        0 & 1 & 1 & 1 & 0 \\
        0 & 0 & 1 & 0 & 0 \\
        0 & 0 & 1 & 0 & 0
\end{bmatrix}\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}\end{quote}

\item {} 
Perform dilation with a long vertical line. (needs a 70x70 size structure element)
\begin{quote}
\begin{gather}
\begin{split}SEd_{70,70} = 
\begin{bmatrix}
        0 & 0 & \dots & 0 & 0 \\
          & \vdots & & \vdots & \\
        1 & 1 & \dots & 1 & 1 \\
          & \vdots & & \vdots & \\
        0 & 0 & \dots & 0 & 0
\end{bmatrix}\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}\end{quote}

\end{enumerate}

\item {} 
Label the morphologically operated image

\item {} 
Remove patches which size is less or equal to 4000 pixels

\item {} 
Label the image again with new labels

\item {} 
Calculate the extreme dimensions of each patch. These values are used as the limiting bounding boxes.

\item {} 
Combine the boxes which are horizontally too close as they are thought to be separate boxes on the same textline.

\item {} 
Return the bounding boxes

\end{enumerate}

\end{fulllineitems}

\index{contStretch() (osearch.OratUtils static method)}

\begin{fulllineitems}
\phantomsection\label{code:osearch.OratUtils.contStretch}\pysiglinewithargsret{\strong{static }\bfcode{contStretch}}{\emph{im}, \emph{a}, \emph{h}}{}
Performs contrast stretching for grayscale images. Pixel intensities are set to 
differ `a' times the average intensity from the original intensity values. The new 
intensity values are sliced to stay between {[}0, 255{]}.
\begin{gather}
\begin{split}I_{stretched} = I_{old} + a*( I_{old} - I_{average} )\end{split}\notag\\\begin{split}I_{new} =
\left\{
\begin{array}[l]{ll}
  0, & I_{stretched} < 0 \\
  I_{stretched}, & 0 \leq I_{stretched} \leq 255\\
  255, & I_{stretched} > 255
\end{array}
\right.\end{split}\notag
\end{gather}\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{im} (\emph{ndarray}) -- The image which contrast is to be stretched

\item {} 
\textbf{a} (\emph{int}) -- multiplication coefficient

\item {} 
\textbf{h} (\emph{int}) -- The height of image. Used as partial image average switch

\end{itemize}

\item[{Returns}] \leavevmode
ndarray -- contrast stretched image

\end{description}\end{quote}

Parameter \emph{h} is a switch which could be used to determine if the average intensity 
is calculated over the whole image or from a small portion of it. Currently it is 
defaulted in the code to newer happen. Originally the idea was that if the image 
is very big, the intensity average would be taken from a small sample. To make the 
function more generic and also because of the nature of the images in Orationes 
project, it was decided that the average is always calculated over the whole image.

\end{fulllineitems}

\index{hfilter() (osearch.OratUtils static method)}

\begin{fulllineitems}
\phantomsection\label{code:osearch.OratUtils.hfilter}\pysiglinewithargsret{\strong{static }\bfcode{hfilter}}{\emph{image}, \emph{diameter}, \emph{height}, \emph{length}, \emph{n}}{}
This function performs homomorphic filtering on grayscale images.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{image} (\emph{ndarray}) -- 2-dimensional ndarray

\item {} 
\textbf{diameter} (\emph{int}) -- filter diameter

\item {} 
\textbf{height} (\emph{int}) -- Height of the image

\item {} 
\textbf{length} (\emph{int}) -- Length of the image

\item {} 
\textbf{n} (\emph{int}) -- Filter order

\end{itemize}

\item[{Returns}] \leavevmode
ndarray -- homomorphically filtered image

\end{description}\end{quote}

The image must in ndarray format. In osearch PIL images are converted to scipy images which 
are in ndarray format. Ndarray format allows easy and fast direct access to the pixel values 
and this function is written entirely only for the ndarrays.

\end{fulllineitems}

\index{padlines() (osearch.OratUtils static method)}

\begin{fulllineitems}
\phantomsection\label{code:osearch.OratUtils.padlines}\pysiglinewithargsret{\strong{static }\bfcode{padlines}}{\emph{imlines}, \emph{llines}, \emph{charlines}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{imlines} (\emph{ndarray}) -- n*1 size ndarray containing the lines (or rather their y-position) got from the image by radontransform

\item {} 
\textbf{llines} (\emph{ndarray}) -- n*2 size ndarray containing the length information of the lines

\item {} 
\textbf{charlines} (\emph{list}) -- list of lists telling the position(s) of searched character(s)/word(s) on each line

\end{itemize}

\item[{Returns}] \leavevmode
ndarray -- wantedlines

\end{description}\end{quote}

Long:
Llines contains the information about the lines got from the XML and also it contains the 
information if some of the lines are remarkably shorter than other lines. That means that, if there are some lines that 
are not found from the image, it is assumed that those non-found lines are the shortest lines according to the XML and 
character count. Those lines are marked as 0 in the second column in llines.

Short:
Llines{[}:,1{]} contains only 1s and 0s. 1 meaning a line with enough letters to be recognized by poormanradon (pmr) 
and 0 meaning a line which is probably undetected by pmr
\begin{description}
\item[{Behavior:}] \leavevmode
Number of lines found from the image using pmr is larger than 
the number of lines calculated from XML:
\begin{quote}

TODO! Currently this case is not handled!
\end{quote}

Number of lines found from the image using pmr is smaller than
the number of lines calculated from XML:
\begin{quote}

Pad the lines according to the information in llines{[}:,1{]}

llines:         imlines:                rlines:
\begin{description}
\item[{{[}1 ----------\textgreater{}{[}100 --------\textgreater{}{[}100}] \leavevmode
1 ----------\textgreater{} 200 --------\textgreater{} 200
1 ----------\textgreater{} 300 --------\textgreater{} 300
1 ----------\textgreater{} 400 --------\textgreater{} 400
0      .--------\textgreater{} 600 --------. NAN
1 /.--------\textgreater{} 700 --------.`600
1 / .-------\textgreater{} 900{]}-------. `700
0  /                                      NAN
1{]}/                                            `900{]}

\end{description}
\end{quote}

Number of lines found from the image using pmr equals to
the number of lines calculated from XML:
\begin{quote}

Pick unique lines from imlines and return them as lines 
the interesting lines.
\end{quote}

\end{description}

\# Jos löydettyjä rivejä on vähemmän kuin xml:ssä rivejä, pitää rivejä
\# tasata ja niiden indeksejä vastaamaan mahdollisimman paljon oikeita
\# rivejä. Oletuksena on, että rivit, joissa on keskimääräistä vähemmän
\# kirjiamia, ei tunnistu poormanradonissa, joten ne jää välistä pois ja ne
\# hylätään kokonaan. Tätä oletusta hyväksi käyttäen kuitenkin korjataan
\# rivien indeksit osoittamaan aina oikeaan riviin.

\end{fulllineitems}

\index{poormanradon() (osearch.OratUtils static method)}

\begin{fulllineitems}
\phantomsection\label{code:osearch.OratUtils.poormanradon}\pysiglinewithargsret{\strong{static }\bfcode{poormanradon}}{\emph{image}, \emph{iname}, \emph{height}, \emph{debug}}{}
Performs a naive radon-transform on the binarized and contrast stretched image and 
tries to determine where the text lines are in the image
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{image} (\emph{ndarray}) -- Image

\item {} 
\textbf{iname} (\emph{string}) -- Image name

\item {} 
\textbf{height} (\emph{int}) -- Image height

\item {} 
\textbf{debug} (\emph{bool}) -- Debug switch

\end{itemize}

\item[{Returns}] \leavevmode
ndarray -- Array containing the lines which are found using radon transform

\end{description}\end{quote}

\end{fulllineitems}

\index{stringparser() (osearch.OratUtils static method)}

\begin{fulllineitems}
\phantomsection\label{code:osearch.OratUtils.stringparser}\pysiglinewithargsret{\strong{static }\bfcode{stringparser}}{\emph{tfile}, \emph{c}}{}
Performs case sensitive search for text file tfile with string or character c (char on default).
Argument c can be any regular expression
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{tfile} (\emph{string}) -- The name of the cleaned XML file

\item {} 
\textbf{c} (\emph{string/char/regular expression}) -- The letter or string that is searched from the tfile

\end{itemize}

\item[{Returns}] \leavevmode
list -- charcount

\item[{Returns}] \leavevmode
list of lists -- charpos

\item[{Returns}] \leavevmode
list of lists -- charlines

\item[{Returns}] \leavevmode
list of lists -- wordlens

\end{description}\end{quote}
\begin{itemize}
\item {} 
\emph{Charcount} is a list containing the lengths of each line.
\begin{itemize}
\item {} 
\code{{[}63, 60, 4, 65, 66, 37, 66, ...{]}}

\end{itemize}

\item {} 
\emph{Charpos} is a list containing lists including the positions of the found characters or the first letters of the found words.
\begin{itemize}
\item {} 
\code{{[}{[}52{]}, {[}10, 47, 62{]}, {[}19, 62{]}, {[}51{]}, ...{]}}

\end{itemize}

\item {} 
\emph{Charlines} is a list of lists where the length of each sublist tells the number of hits on that line and the element values representing the line number from the XML file.
\begin{itemize}
\item {} 
\code{{[}{[}3{]}, {[}4, 4, 4{]}, {[}6, 6{]}, {[}7{]}, ...{]}}

\end{itemize}

\item {} 
\emph{Wordlens} is a list containing lists containing the lengths of the words on each line.
\begin{itemize}
\item {} 
\code{{[}{[}3{]}, {[}3, 3, 3{]}, {[}3, 3{]}, {[}3{]}, ...{]}}

\end{itemize}

\end{itemize}

\end{fulllineitems}


\end{fulllineitems}



\section{Helper Functions}
\label{code:helper-functions}\index{HFun (class in osearch)}

\begin{fulllineitems}
\phantomsection\label{code:osearch.HFun}\pysigline{\strong{class }\code{osearch.}\bfcode{HFun}}
\end{fulllineitems}



\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{modindex}

\item {} 
\emph{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{o}
\item {\texttt{osearch}}, \pageref{code:module-osearch}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
